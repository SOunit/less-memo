## 結論

- **「ヘッダー＋メインはスクロール／フッターだけ常に画面下で固定」かつ「純CSSのみ」なら、`footer` 分の余白をどこかで確保するやり方が本質的に正解です。**  
- **Grid / Flex を使っても、「固定された要素は通常フローから外れる」という仕様は変わらないので、結局どこかで同じようなオフセット（余白・高さ計算）を持つ必要があります。**  
- 「原始的」に見えますが、**設計（トークン化・責務分離）さえちゃんとしていれば、これは現在でも普通に通用するベストプラクティスの一つ**です。

---

## なぜ余白が必要なのか（原理）

- `position: fixed` を付けた時点で、`footer` は **レイアウトフローから完全に外れます**。
- ブラウザは「下に固定されている要素のぶんだけ `main` のスクロール領域を短くしよう」とは**自動では考えてくれません**。
- なので、
  - `main` 側に `padding-bottom` / `margin-bottom` などで**下側オフセットを足す**
  - もしくは `main` の最小高さを `calc(100vh - フッター高さ)` にする  
  など、**開発側が「フッターがかぶる領域」を明示的に差し引く必要**があります。

Grid / Flex を導入しても、「`footer` を `position: fixed` でビューポートに固定する」瞬間に、同じ問題にぶつかります。  
**レイアウトシステム（Grid/Flex）は「フロー内の要素」にしか効かない**からです。

---

## Grid / Flex で「もっとスマート」になるか？

### 1. Grid / Flex でできること

- `header / main / footer` の**並び順や伸縮**をきれいに書ける  
  （例: `grid-template-rows: auto 1fr auto` など）
- 「中身が少なくてもページ最下部にフッターを置く」いわゆる **sticky footer** は、Grid/Flex だとすごく書きやすい

ですが、今回の要件は

> ヘッダーとメインはスクロールするが、フッターは常に画面下に固定（スクロールしても付いてくる）

なので、**フッターをビューポートに対して固定**する必要があり、
結局 `position: fixed`（or ほぼ同等の仕組み）から逃れられません。

### 2. 結局どうなるか

- `footer` を `position: fixed` にした時点で、**Grid / Flex が管理できる「高さの帳尻合わせ」は効かなくなる**
- よって **Grid/Flexを導入しても、「footer分のオフセットをどこかで差し引く」という発想自体は変わりません**

したがって、「Gridにすれば余白を気にしなくてよくなる」という意味での“もっとスマート”なやり方は、**現状のCSS仕様では存在しない**、という答えになります。

---

## 今のアプローチを「今風・保守的」にするコツ

「余白を取る」こと自体は避けられないので、  
**いかにそれを“設計としてきれいにするか”**がポイントになります。

### パターンA：高さほぼ固定／デザインで縛れるケース（純CSSで完結）

LESS でトークンを切る:

```less
@footer-height: 56px;

.app {
  min-height: 100vh;
  padding-bottom: @footer-height;
  box-sizing: border-box;
}

.footer {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  height: @footer-height;
}
```

**ポイント**

- 高さは `@footer-height` の **1か所だけで管理**  
- `padding-bottom` 側と `footer` 自体の `height` がズレないので、**チーム開発でも理由が明確**

「原始的」に見えるのは、たいてい

- ハードコードされた `56px` があちこちに散らばっている
- コメントや命名で意図が共有されていない

という **設計の問題**であって、やっていること自体は今でもよく使われます。

### パターンB：本当に可変高で、かつ常に固定したい（JS＋CSSカスタムプロパティ）

**「高さをどうこうする責務」を JS に閉じ込める**パターンです。

CSS 側:

```css
:root {
  --footer-height: 0px;
}

.app {
  min-height: 100vh;
  padding-bottom: var(--footer-height);
  box-sizing: border-box;
}

.footer {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
}
```

JS 側（ざっくりイメージ）:

```js
function updateFooterHeight() {
  const footer = document.querySelector('.js-fixed-footer');
  if (!footer) return;
  const h = footer.offsetHeight;
  document.documentElement.style.setProperty('--footer-height', `${h}px`);
}

window.addEventListener('load', updateFooterHeight);
window.addEventListener('resize', updateFooterHeight);
// SPA ならルーティング変更時にも呼ぶ
```

**ポイント**

- CSS は「`--footer-height` 分余白を開ける」という**ルールだけ**を持つ
- 実際の高さの取得・反映は JS に閉じ込め、**1ファイルに責務を集約**できる
- フッターの中身をいじる人は高さをまったく意識しなくてよくなる

「余白を確保する」というアイデア自体は同じですが、

- オフセット値を **変数（トークン or CSS変数）で集中管理**
- 値の更新を JS に任せるかどうか

という設計で、かなり「今風」かつ大規模向けにできます。

---

## まとめ

- **Grid / Flex を使っても、「固定フッターがコンテンツを隠さないようにするには、どこかでオフセット（余白 or 高さ計算）を入れる」という本質は変わりません。**
- なので、今やっている **「footer の分だけ余白を確保する」アプローチ自体は正しく、ベストカテゴリに入る**やり方です。
- 「原始的」に見えないようにするには、
  - 高さをトークン化して1か所で管理
  - もっと柔軟にしたければ、**JS＋CSS変数**で高さを自動反映
  といった形で、**責務と値の管理を整理する**のがポイントです。

「練習プロジェクト」としては、  
1. 今の LESS トークン方式（純CSS）  
2. JS＋CSS変数方式（可変高対応）  
の2パターンを実装して比較してみると、「どこまでを CSS で、どこからを JS でやるか」の感覚がかなりつかめると思います。